import numpy as np
import pandas as pd
from scipy.signal import find_peaks
from scipy.fft import fft
from statsmodels.tsa.seasonal import STL
import os
import requests
import urllib.request
import plotly.graph_objs as go

from astropy.timeseries import LombScargle

from utils import get_best_period, show_simple_scatter


tides_data = pd.read_csv("Tide Prediction.csv")

heights_df = tides_data.loc[
    tides_data["stationID"] == "Aranmore", ["time", "Water_Level"]
]

heights_df['time'] = pd.to_datetime(heights_df['time'])

dates = heights_df['time'].to_numpy()
times = (heights_df["time"] - pd.Timestamp("1970-01-01T00:00:00Z")) // pd.Timedelta('1s')

#seconds = np.asarray([t.total_seconds() for t in times])
minutes = times.to_numpy() / 60.0

first_minute = minutes[0]

# minutes and y are now np.float64
minutes = minutes - first_minute
y = heights_df["Water_Level"].to_numpy().astype(float)

show_simple_scatter(heights_df["time"], y, "Tides vs data time", "datetime", "height")

show_simple_scatter(minutes, y, "Tides", "minutes", "height")

ls = LombScargle(minutes, y)

# #Below block generated by ChatGPT
# dt = np.mean(np.diff(minutes))
# fs = 1 / dt
# nyquist = fs / 2
# min_frequency = 1 / (minutes[-1] - minutes[0])
# max_frequency = nyquist
# num_frequencies = int(len(minutes) / 2)

# # Lets see if ChatGPT knew how to pick sensible defaults.
# frequency, power = ls.autopower(minimum_frequency=min_frequency, maximum_frequency=max_frequency, samples_per_peak=num_frequencies, method='fast')
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data half day period", "Period (days)", "Power")


def check_for_periods(ls, min_period, max_period):
    max_frequency = 1.0 / min_period
    min_frequency = 1.0 / max_period
    frequency, power = ls.autopower(minimum_frequency=min_frequency, maximum_frequency=max_frequency)
    best_period = get_best_period(frequency, power)
    prob = ls.false_alarm_probability(power.max())
    return frequency, power, best_period, prob
    # print("Best period: ", get_best_period(frequency, power) / 60.0 / 24.0)
    # print(ls.false_alarm_probability(power.max()))
    
    # show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data half day period", "Period (days)", "Power")

# Below is our testing strategy, units are in minutes


# def get_intervals(arr, interval_size):
#     arr_min, arr_max = np.min(arr), np.max(arr)
#     arr_range = arr_max - arr_min
#     n = int(np.ceil(arr_range / interval_size))
#     actual_interval_size = arr_range / n
#     intervals = [(arr_min + i*actual_interval_size, arr_min + (i+1)*actual_interval_size) for i in range(n)]    
#     return intervals

period_ranges = [(10, 144), (144, 14400), (14400, 144000), (144000, 1440000), (1440000, 14400000), (1440000, 14400000)]

for i, j in period_ranges:
    frequency, power, best_period, prob = check_for_periods(ls, i, j)
    print("Checking for periods between {start} and {end} days".format(start = i / 60.0 / 24.0, end = j / 60.0 / 24.0))
    print("Period of likely cyclicality ", best_period / 60.0 / 24.0) # Convert to days
    print("probability of a false alarm ", prob)
    print("Power ", power.max())
    print()

# # Check periods from 0.1 days to 10 days
# frequency, power, best_period, prob = check_for_periods(ls, 144, 14400)
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data 0.1 day to 10 days", "Period (days)", "Power")


# # Check periods from 10 days to 100 days
# frequency, power, best_period, prob = check_for_periods(ls, 14400, 144000)
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data 10 days to 100 days", "Period (days)", "Power")


# # Check periods from 100 days to 1000 days
# frequency, power, best_period, prob = check_for_periods(ls, 144000, 1440000)
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data 100 days to 1000 days", "Period (days)", "Power")


# # Check for periods from 1000 days to 10000 days
# frequency, power, best_period, prob = check_for_periods(ls, 1440000, 14400000)
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data 1000 days to 10000 days", "Period (days)", "Power")


# # Check for periods from 10000 to 100000 days
# frequency, power, best_period, prob = check_for_periods(ls, 1440000, 14400000)
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data 10000 days to 100000 days", "Period (days)", "Power")




# # Below gives period of 0.52 days
# frequency, power = ls.autopower(minimum_frequency=0.0001, maximum_frequency=0.005)
# print("Best period: ", get_best_period(frequency, power) / 60.0 / 24.0)
# print(ls.false_alarm_probability(power.max()))
# #show_simple_scatter(frequency, power, "Lomb Scargle for Tides Data 0.", "frequency", "Power")
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data half day period", "Period (days)", "Power")

# # Below gives a period of 31.9 days
# frequency, power = ls.autopower(minimum_frequency=0.00001, maximum_frequency=0.0005)
# print("Best period: ", get_best_period(frequency, power) / 60.0 / 24.0)
# print(ls.false_alarm_probability(power.max()))
# #show_simple_scatter(frequency, power, "Lomb Scargle for Tides Data 0.", "frequency", "Power")
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data 1 month period", "Period (days)", "Power")

# # Below gives a period of 368 days
# frequency, power = ls.autopower(minimum_frequency=0.000001, maximum_frequency=0.00001)
# print("Best period: ", get_best_period(frequency, power) / 60.0 / 24.0)
# print(ls.false_alarm_probability(power.max()))
# #show_simple_scatter(frequency, power, "Lomb Scargle for Tides Data 0.", "frequency", "Power")
# show_simple_scatter(1.0 / frequency / 60.0 / 24.0, power, "Lomb Scargle for Tides Data 1 year period", "Period (days)", "Power")
